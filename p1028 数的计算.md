# [NOIP2001 普及组] 数的计算

## 题目描述

给出正整数 $n$，要求按如下方式构造数列：

1. 只有一个数 $n$ 的数列是一个合法的数列。
2. 在一个合法的数列的末尾加入一个正整数，但是这个正整数不能超过该数列最后一项的一半，可以得到一个新的合法数列。

请你求出，一共有多少个合法的数列。两个合法数列 $a, b$ 不同当且仅当两数列长度不同或存在一个正整数 $i \leq |a|$，使得 $a_i \neq b_i$。

## 输入格式

输入只有一行一个整数，表示 $n$。

## 输出格式

输出一行一个整数，表示合法的数列个数。

## 样例 #1

### 样例输入 #1

```
6
```

### 样例输出 #1

```
6
```

## 提示

### 样例 1 解释

满足条件的数列为：
- $6$
- $6, 1$
- $6, 2$
- $6, 3$
- $6, 2, 1$
- $6, 3, 1$

### 数据规模与约定

对于全部的测试点，保证 $1 \leq n \leq 10^3$。

### 说明

本题数据来源是 NOIP 2001 普及组第一题，但是原题的题面描述和数据不符，故对题面进行了修改，使之符合数据。原题面如下，谨供参考：

> 我们要求找出具有下列性质数的个数（包含输入的正整数 $n$）。
>
> 先输入一个正整数 $n$（$n \le 1000$），然后对此正整数按照如下方法进行处理：
>
> 1. 不作任何处理；
> 2. 在它的左边拼接一个正整数，但该正整数不能超过原数，或者是上一个被拼接的数的一半；
> 3. 加上数后，继续按此规则进行处理，直到不能再加正整数为止。

感谢 @[dbxxx](/user/120868) 对本题情况的反馈，原题面的问题见[本贴](https://www.luogu.com.cn/discuss/526184)。

### Thoughts
开始以为很简单的递归，发现超时。
需要减少对于小数字重复的递归计算——存储在一个 vector 里面直接调用
这里用了 trick：因为我从小到大计算然后填入 vector，我在 function 里面直接取用 vec[i] 就不会出错
```
#include <iostream>
#include <vector>

std::vector<int> ln_lst(1000, 0);

int legal_num(int x) {
    int top = x / 2;
    int outp = 0;
    if (x == 1 || x == 0) return 1;
    for (int i = 0; i != top + 1; ++i) {
        outp += ln_lst[i];
    };
    return outp;
};

int main() {
    int n;
    std::cin >> n;
    for (int j = 0; j != n+1; ++j) {
        ln_lst[j] = legal_num(j);
        //std::cout << ln_lst[j] << std::endl;
    };


    std::cout << ln_lst[n] << std::endl;
    return 0;
}
```