# [NOIP2003 普及组] 栈

## 题目背景

栈是计算机中经典的数据结构，简单的说，栈就是限制在一端进行插入删除操作的线性表。

栈有两种最重要的操作，即 pop（从栈顶弹出一个元素）和 push（将一个元素进栈）。

栈的重要性不言自明，任何一门数据结构的课程都会介绍栈。宁宁同学在复习栈的基本概念时，想到了一个书上没有讲过的问题，而他自己无法给出答案，所以需要你的帮忙。

## 题目描述

![](https://cdn.luogu.com.cn/upload/image_hosting/5qxy9fz2.png)

宁宁考虑的是这样一个问题：一个操作数序列，$1,2,\ldots ,n$（图示为 1 到 3 的情况），栈 A 的深度大于 $n$。

现在可以进行两种操作，

1. 将一个数，从操作数序列的头端移到栈的头端（对应数据结构栈的 push 操作）
2. 将一个数，从栈的头端移到输出序列的尾端（对应数据结构栈的 pop 操作）

使用这两种操作，由一个操作数序列就可以得到一系列的输出序列，下图所示为由 `1 2 3` 生成序列 `2 3 1` 的过程。

![](https://cdn.luogu.com.cn/upload/image_hosting/8uwv2pa2.png)

（原始状态如上图所示）

你的程序将对给定的 $n$，计算并输出由操作数序列 $1,2,\ldots,n$ 经过操作可能得到的输出序列的总数。

## 输入格式

输入文件只含一个整数 $n$（$1 \leq n \leq 18$）。

## 输出格式

输出文件只有一行，即可能输出序列的总数目。

## 样例 #1

### 样例输入 #1

```
3
```

### 样例输出 #1

```
5
```

## 提示

**【题目来源】**

NOIP 2003 普及组第三题

### 分析
先来看一下题目想干啥：
这道题想让我们来数一下1~n通过栈操作后有多少种出栈情况（暴力枚举其实大概可以打就是过不了）

正经分析一下
这是一道dp，不算太难，看式子！
f[i][j]=f[i-1][j]+f[i+1][j-1] (i>=1) ----> 卡特兰数的表达式
f[i][j]=f[i+1][j-1] (i=0)
因为栈里的数字只有两种选择，出去和不出去。

如果出去栈里的数字个数-1；如果不出去就要压栈，未进站的数字进来一个，未进栈的个数-1，栈内个数+1，所以f[i][j]=f[i-1][j]+f[i+1][j-1]
当栈内没有数字时，只能进栈，且此操作后的出栈情况就要取决于f[i+1][j-1]
（f[i][j]，i表示栈内数字的个数，j表示未进栈数字的个数，f计当前状态下有几种情况）
这样来看的话，边界也就很清楚了（当栈外没有数字时，只能出栈）

f[i][0]=1(0<=j<=n)
dp式子和边界出来了，代码还会远吗？

啥都不说了，上代码
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>//为了NOIP不用万能头文件
using namespace std;
int f[20][20];//数据就给到18，开个20算大方的
int n;
int main()
{
    memset(f,0,sizeof(f));
    scanf("%d",&n);
    for(int i=0;i<=n;i++)
       f[i][0]=1;//边界一定要有
    for(int j=1;j<=n;j++)
       for(int i=0;i<=n;i++)
       //我们要推f[0][n]，所以i要从零开始跑
        {
          if(i>=1) 
            f[i][j]=f[i-1][j]+f[i+1][j-1];
          if(i==0)//栈内没有东西
            f[i][j]=f[i+1][j-1];
        }
    printf("%d",f[0][n]);
    return 0;
}
```

又解
```cpp
#include <cstdio>

int n, f[30];
int main()
{
    //递推实现卡特兰数 
    scanf("%d", &n);
    f[0] = 1, f[1] = 1;
    for(int i=2; i<=n; i++)              
        for(int j=0; j<i; j++) 
            f[i] += f[j] * f[i-j-1];     //递推公式 
    printf("%d", f[n]);
    return 0;
}
```

### 思考
实际上遇到复杂问题先设未知量 i, j，然后再基于题目中的操作方式进行“一步”的递推，相应有 i+-1, j+-1 等变化。然后给出初始条件/极限条件，以及根据题目的实际情况的限定给出 if 类的条件。