# [NOIP2003 普及组] 麦森数

## 题目描述

形如 $2^{P}-1$ 的素数称为麦森数，这时 $P$ 一定也是个素数。但反过来不一定，即如果 $P$ 是个素数，$2^{P}-1$ 不一定也是素数。到 1998 年底，人们已找到了 37 个麦森数。最大的一个是 $P=3021377$，它有 909526 位。麦森数有许多重要应用，它与完全数密切相关。

任务：输入 $P(1000<P<3100000)$，计算 $2^{P}-1$ 的位数和最后 $500$ 位数字（用十进制高精度数表示）

## 输入格式

文件中只包含一个整数 $P(1000<P<3100000)$

## 输出格式

第一行：十进制高精度数 $2^{P}-1$ 的位数。

第 $2\sim 11$ 行：十进制高精度数 $2^{P}-1$ 的最后 $500$ 位数字。（每行输出 $50$ 位，共输出 $10$ 行，不足 $500$ 位时高位补 $0$）

不必验证 $2^{P}-1$ 与 $P$ 是否为素数。

## 样例 #1

### 样例输入 #1

```
1279
```

### 样例输出 #1

```
386
00000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000
00000000000000104079321946643990819252403273640855
38615262247266704805319112350403608059673360298012
23944173232418484242161395428100779138356624832346
49081399066056773207629241295093892203457731833496
61583550472959420547689811211693677147548478866962
50138443826029173234888531116082853841658502825560
46662248318909188018470682222031405210266984354887
32958028878050869736186900714720710555703168729087
```

## 提示

**【题目来源】**

NOIP 2003 普及组第四题

### my code
```cpp
#include <iostream>
#include <vector>
#include <cmath>

std::vector<int> number(500, 0);

void times_2() {
    int j = 0;
    long long forward = 0;
    while ((number[j] != 0 || forward != 0) && j != 500) {
        int mid = number[j] * 2 + forward;
        forward = (mid) / 10;
        number[j] = (mid) % 10;
        ++j;
    };
}

void minus_1() {
    int j = 0;
    while (number[j] == 0) {
        number[j] += 10;
        number[j + 1] -= 1;
        ++j;
    };
    --number[0];
}


int main() {
    long long p;
    std::cin >> p;
    number[0] = 2;
    for (int i = 0; i != p; ++i) {
        times_2();
    };
    minus_1();

    //位数
    int out = p * log10(2);
    std::cout << out + 1 << std::endl;


    //last 50 digits
    for (int i = 0; i != 10; ++i) {
        for (int j = 0; j != 50; ++j) {
            std::cout << number[499 - j - i * 50];
        };
        std::cout << std::endl;
    };

    return 0;
}
```
过于暴力导致计算机算不出来

### 巧妙地避开“无限”次循环
这题全是用快速幂的，其实可以不用，310万乘500等于15亿，常数好能过。题解里有一篇不用快速幂压位的解法，但是代码长得要死。所以，以下是30行以内的代码：（150ms以内）
首先，我们要计算位数。我们知道10^k有k+1位，而k=lg(10^k)。所以2^p的位数是lg(2^p)+1=p*lg(2)。那么把p读进来之后直接cout出位数就行了。
下面解决500位求值的问题：这里还是开一个a[501]的unsigned long long数组，记为ull，然后还是用每个元素表示1位数，没错，是1位数，这样时间够而且代码简单。每次乘一轮不要乘2，乘2^60（9乘以2的60次方刚好不会溢出），记得把p多减掉59就行了。然后你发现15亿除以60等于2500万，貌似可以...自己机器上只用了半秒。
代码：
```cpp
#include <iostream>
#include <cstdio>
#include <cmath>
using namespace std;
typedef unsigned long long ull;
ull a[501]={1};
int main()
{
	int p;
	cin>>p;
	cout<<(int)(p*log10(2))+1<<endl;//log10才是以十为底的对数
	for(;p>0;p-=60)//每次减掉60次幂
	{
		ull f=0;//进位
		for(int i=0;i<500;i++)
		{
			if(p>60)a[i]<<=60;
			else a[i]<<=p;//如果剩下的不够60了就不要乘60了，乘p
			a[i]+=f;
			f=a[i]/10;
			a[i]%=10;
		}
	}
	a[0]-=1;//千万不要忘记减1，否则你会和我第一次一样WA掉全部
	for(int i=499;i>=0;i--)
	{
		putchar(a[i]+'0');
		if(i%50==0)putchar('\n');
	}
	return 0;
}
```

### 快速幂
快速幂（也称为快速指数或幂模算法）是一种高效计算大数幂的算法，尤其在模运算中非常有用。它的主要思想是利用幂的二进制表示来减少乘法的次数，从而加快计算速度。

#### 算法原理

对于计算 \(a^b\)，其中 \(a\) 是底数，\(b\) 是指数，快速幂算法会将指数 \(b\) 转换为二进制表示，然后通过迭代来计算结果。对于指数 \(b\) 的每一位二进制数，算法会计算 \(a\) 的相应幂次，并将结果累乘起来。

#### 算法步骤

1. 将指数 \(b\) 转换为二进制表示。
2. 初始化结果 \(res = 1\)。
3. 遍历指数 \(b\) 的每一位二进制数（从最低位到最高位）：
   - 如果当前位是 1，将 \(res\) 乘以当前的 \(a\) 的幂次并更新 \(res\)。
   - 不论当前位是什么，都将 \(a\) 乘方，即 \(a = a^2\)。
4. 返回结果 \(res\)。

#### 代码示例（C++）

```cpp
#include <iostream>

long long fast_pow(long long a, long long b) {
    long long res = 1;
    a = a % (1e9 + 7); // 如果涉及到模运算，可以先将底数模上
    while (b > 0) {
        if (b & 1) { // 检查当前指数的最低位是否为1
            res = (res * a) % (1e9 + 7);
        }
        a = (a * a) % (1e9 + 7);
        b >>= 1; // 将指数右移一位
    }
    return res;
}

int main() {
    long long a = 2;
    long long b = 10;
    std::cout << "Result: " << fast_pow(a, b) << std::endl;
    return 0;
}
```

#### 应用场景

快速幂算法在很多领域都有应用，比如：

1. **密码学**：在加密算法中，经常需要计算大数的幂。
2. **数论**：在处理涉及大指数的问题时，如费马小定理或欧拉定理。
3. **编程竞赛**：在算法竞赛中，快速幂可以高效解决多项式取模、矩阵快速乘法等问题。

快速幂算法的时间复杂度大约为 \(O(\log b)\)，其中 \(b\) 是指数，这使得它比简单的迭代方法要快得多，特别是在指数非常大的情况下。

#### AC Code
```cpp
#include<cstdio>
#include<cmath>
#include<cstring>
using namespace std;
int f[1001],p,res[1001],sav[1001];//乘法要开两倍长度
void result_1()
{
    memset(sav,0,sizeof(sav));
    for(register int i=1;i<=500;i+=1)
        for(register int j=1;j<=500;j+=1)
            sav[i+j-1]+=res[i]*f[j];//先计算每一位上的值（不进位）
    for(register int i=1;i<=500;i+=1)
    {
        sav[i+1]+=sav[i]/10;//单独处理进位问题，不容易出错
        sav[i]%=10;
    }
    memcpy(res,sav,sizeof(res));//cstring库里的赋值函数，把sav的值赋给res
}
void result_2()//只是在result_1的基础上进行了细微的修改
{
    memset(sav,0,sizeof(sav));
    for(register int i=1;i<=500;i+=1)
        for(register int j=1;j<=500;j+=1)
            sav[i+j-1]+=f[i]*f[j];
    for(register int i=1;i<=500;i+=1)
    {
        sav[i+1]+=sav[i]/10;
        sav[i]%=10;
    }
    memcpy(f,sav,sizeof(f));
}
int main()
{
    scanf("%d",&p);
    printf("%d\n",(int)(log10(2)*p+1));
    res[1]=1;
    f[1]=2;//高精度赋初值
    while(p!=0)//快速幂模板
    {
        if(p%2==1)result_1();
        p/=2;
        result_2();
    }
    res[1]-=1;
    for(register int i=500;i>=1;i-=1)//注意输出格式，50个换一行，第一个不用
        if(i!=500&&i%50==0)printf("\n%d",res[i]);
        else printf("%d",res[i]);
    return 0;
}
```